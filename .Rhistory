WC.UC.full$EN.POP.DNST <- NULL
WC.UC.full$EN.RUR.DNST <- NULL
WC.UC.full$SP.RUR.TOTL <- NULL
WC.UC.full$SP.RUR.TOTL.ZG <- NULL
WC.UC.full$SP.RUR.TOTL.ZS <- NULL
WC.UC.full$EN.URB.LCTY.UR <- NULL
PreGTD <- merge(GTD2, WC.UC.full, by=c("merge2"), all.x=TRUE)
PreGTD  <- PreGTD [order(-PreGTD$HUMscale, na.last=TRUE) , ]
# bring the lat lon data together from both the GTD and the city data sets
PreGTD$latitude <- ifelse(is.na(PreGTD$latitude), as.numeric(PreGTD$lat), as.numeric(PreGTD$lat))
PreGTD$longitude <- ifelse(is.na(PreGTD$longitude), as.numeric(PreGTD$long), as.numeric(PreGTD$long))
# Introduce loged ranks
PreGTD["Rank01.C"] <-((((PreGTD$RANK.Country-1)/(PreGTD$Rank.C.MAX-1))-1)*-1)
PreGTD["Rank01.W"] <-((((PreGTD$RANK.World-1)/(PreGTD$Rank.W.MAX-1))-1)*-1)
# better names before subsetting
PreGTD["GTD.city"] <- PreGTD$city
PreGTD["WCUC.city.old"] <- PreGTD$old.name
PreGTD["WCUC.city"] <- PreGTD$name
PreGTD["merge"]<- PreGTD$merge.x
# limit and order the new PreGTD
PreGTD <- subset(PreGTD, select=c(eventid, iyear, imonth, iday, country_txt, region_txt, GTD.city, WCUC.city, WCUC.city.old,
latitude, longitude, pop.that.year, Rel.CS, inUC, aroundUC, RANK.Country, Rank.C.MAX, Rank01.C,
RANK.World, Rank.W.MAX, Rank01.W, capital, largestC, Closest.Urban.Center,largest.UC,
coastalMC, WC.UC.dist.km, attacktype1, targtype1, targsubtype1, weaptype1, weapsubtype1,
TUPscale, PROPscale, HUMscale, Extra.WAR.In, Extra.WAR.Out, Intra.WAR, Inter.WAR, old.pop,
merge, original.city, coast.dist, coast.dist.MIN, access, access.MIN, light, LIGHT.MAX, nldi,
nldi.MAX, urbn.cover, city.gdp, gdp.MAX, dens.90, dens.90.MAX, dens.95, dens.95.MAX, dens.00, dens.00.MAX,
dens.05, dens.05.MAX, dens.10, dens.10.MAX))
# fill rural atacks (= no city found) with respective data
PreGTD$coastalMC[is.na(PreGTD$coastalMC)] <- 0
PreGTD$capital[is.na(PreGTD$capital)] <- 0
PreGTD$largest.UC[is.na(PreGTD$largest.UC)] <- 0
PreGTD$TUPscale[is.na(PreGTD$TUPscale)] <- 0
PreGTD$PROPscale[is.na(PreGTD$PROPscale)] <- 0
PreGTD$HUMscale[is.na(PreGTD$HUMscale)] <- 0
PreGTD$Extra.WAR.In[is.na(PreGTD$Extra.WAR.In)] <- 0
PreGTD$Extra.WAR.Out[is.na(PreGTD$Extra.WAR.Out)] <- 0
PreGTD$Intra.WAR[is.na(PreGTD$Intra.WAR)] <- 0
PreGTD$Inter.WAR[is.na(PreGTD$Inter.WAR)] <- 0
PreGTD$Rel.CS[is.na(PreGTD$Rel.CS)] <- 0
PreGTD$Rank01.C[is.na(PreGTD$Rank01.C)] <- 0
PreGTD$Rank01.W[is.na(PreGTD$Rank01.W)] <- 0
PreGTD$inUC[is.na(PreGTD$inUC)] <- 0
PreGTD$aroundUC[is.na(PreGTD$aroundUC)] <- 0
PreGTD$RANK.Country <- ifelse(is.na(PreGTD$RANK.Country), as.numeric(PreGTD$Rank.Country.MAX), PreGTD$RANK.Country)
PreGTD$RANK.World <- ifelse(is.na(PreGTD$RANK.World), as.numeric(PreGTD$Rank.World.MAX), PreGTD$RANK.World)
# write a csv, just to be sure
write.csv(PreGTD, file="TerrorData/Pregtd.csv")
rm(WC.UC.merge, WC.UC.time, GTDcountry, GTDcity, GTDyear, GTD2, WC.UC.full)
View(PreGTD)
PreGTD <- subset(PreGTD, select=c(eventid, iyear, imonth, iday, country_txt, region_txt, GTD.city, WCUC.city, WCUC.city.old,
latitude, longitude, pop.that.year, Rel.CS, inUC, aroundUC, RANK.Country, Rank.C.MAX, Rank01.C,
RANK.World, Rank.W.MAX, Rank01.W, capital, largestC, Closest.Urban.Center,largest.UC,
coastalMC, WC.UC.dist.km, attacktype1, targtype1, targsubtype1, weaptype1, weapsubtype1,
TUPscale, PROPscale, HUMscale, Extra.WAR.In, Extra.WAR.Out, Intra.WAR, Inter.WAR, old.pop,
merge, original.city, coast.dist, coast.dist.MIN, access, light, LIGHT.MAX, nldi,
nldi.MAX, urbn.cover, city.gdp, gdp.MAX, dens.90, dens.90.MAX, dens.95, dens.95.MAX, dens.00,
dens.00.MAX, dens.05, dens.05.MAX, dens.10, dens.10.MAX))
# fill rural atacks (= no city found) with respective data
PreGTD$coastalMC[is.na(PreGTD$coastalMC)] <- 0
PreGTD$capital[is.na(PreGTD$capital)] <- 0
PreGTD$largest.UC[is.na(PreGTD$largest.UC)] <- 0
PreGTD$TUPscale[is.na(PreGTD$TUPscale)] <- 0
PreGTD$PROPscale[is.na(PreGTD$PROPscale)] <- 0
PreGTD$HUMscale[is.na(PreGTD$HUMscale)] <- 0
PreGTD$Extra.WAR.In[is.na(PreGTD$Extra.WAR.In)] <- 0
PreGTD$Extra.WAR.Out[is.na(PreGTD$Extra.WAR.Out)] <- 0
PreGTD$Intra.WAR[is.na(PreGTD$Intra.WAR)] <- 0
PreGTD$Inter.WAR[is.na(PreGTD$Inter.WAR)] <- 0
PreGTD$Rel.CS[is.na(PreGTD$Rel.CS)] <- 0
PreGTD$Rank01.C[is.na(PreGTD$Rank01.C)] <- 0
PreGTD$Rank01.W[is.na(PreGTD$Rank01.W)] <- 0
PreGTD$inUC[is.na(PreGTD$inUC)] <- 0
PreGTD$aroundUC[is.na(PreGTD$aroundUC)] <- 0
PreGTD$RANK.Country <- ifelse(is.na(PreGTD$RANK.Country), as.numeric(PreGTD$Rank.Country.MAX), PreGTD$RANK.Country)
PreGTD$RANK.World <- ifelse(is.na(PreGTD$RANK.World), as.numeric(PreGTD$Rank.World.MAX), PreGTD$RANK.World)
# write a csv, just to be sure
write.csv(PreGTD, file="TerrorData/Pregtd.csv")
View(PreGTD)
PreGTD <- subset(PreGTD, select=c(eventid, iyear, imonth, iday, country_txt, region_txt, GTD.city, WCUC.city.old,
latitude, longitude, pop.that.year, Rel.CS, inUC, aroundUC, RANK.Country, Rank.C.MAX, Rank01.C,
RANK.World, Rank.W.MAX, Rank01.W, capital, largestC, Closest.Urban.Center,largest.UC,
coastalMC, WC.UC.dist.km, attacktype1, targtype1, targsubtype1, weaptype1, weapsubtype1,
TUPscale, PROPscale, HUMscale, Extra.WAR.In, Extra.WAR.Out, Intra.WAR, Inter.WAR, old.pop,
merge, original.city, coast.dist, coast.dist.MIN, access, light, LIGHT.MAX, nldi,
nldi.MAX, urbn.cover, city.gdp, gdp.MAX, dens.90, dens.90.MAX, dens.95, dens.95.MAX, dens.00,
dens.00.MAX, dens.05, dens.05.MAX, dens.10, dens.10.MAX))
write.csv(PreGTD, file="TerrorData/Pregtd.csv")
View(WC.UC.dist)
if(file.exists("Cache/WC.UC.dist.csv")) {WC.UC.dist <- read.csv("Cache/WC.UC.dist.gis.csv")} else{source("1.c - City Data.R")}
View(WC.UC.dist)
View(WC.UC.dist)
View(PreGTD)
setwd("C:/Users/Lokus/Dropbox/UrbanTerror")
WC.UC.dist <- read.csv("Cache/WC.UC.dist.old.csv")
# Country level data from the World Bank Development Indicators (WDI) and the The Correlates of War (COW) project data on wars.
if(file.exists("Cache/CountryData.csv")){CountryData <- read.csv("Cache/CountryData.csv")} else{source("1.b - Country Data.R")}
# Now with both City and Country Data gathered, we can fill sime gaps in the Wold Banks largest city population indicator
source('SmallScripts/fill.EN.URB.LCTY.UR.R')
# Bring Country level Data for 2010 into the WC.UC Data for the purpose of changing city population to fit WDI aggregates
G <- WC.UC.dist
G["realpop"] <- G$pop
G["year"] <- 2010
G["country"] <- G$country.etc
GM <- merge(G, CountryData, by=c("country", "year"), all.x=TRUE)
G <- subset(GM, select=c(realpop, country, name, capital, pop, largestC, part.of.urban.center,
Closest.Urban.Center, largest.UC, Population,
EN.URB.LCTY.UR, EN.URB.MCTY, SP.URB.TOTL,SP.POP.TOTL))
rm(GM)
# if largest City was attacked, we use the EN.URB.LCTY.UR
#(WDI for largest city population) instead of the old population
G$realpop <- ifelse(G$largestC==1&(!is.na(G$EN.URB.LCTY.UR)),
G$EN.URB.LCTY.UR, G$realpop)
# if UC was attacked, we use the UC Population instead of the previous city population
G$realpop <- ifelse(G$part.of.urban.center==TRUE, G$Population, G$realpop)
# if UC attacked & its the largest UC, use EN.URB.LCTY.UR
G$realpop <- ifelse((G$part.of.urban.center==TRUE&(!is.na(G$EN.URB.LCTY.UR))),
(ifelse(G$largest.UC==1,G$EN.URB.LCTY.UR, G$realpop)), G$realpop)
#################################
# finding sums in the WC.UC Data  for the 3 categories (largest, UC and rest) we have WDI Data for
# At this point, it makes sense to bring UC name in the form of city-like name
X <- G$Closest.Urban.Center
X <- gsub(".*,","",X)
source('SmallScripts/CleanSpecialCharacters.R')
G["UC"] <- X
rm(X)
# sum of the population living in urban conglomerates of over 1m, excluding the largest city
G.UC.SUMS <- subset(G, select = c(realpop, country, name, pop, Population, EN.URB.LCTY.UR, EN.URB.MCTY, SP.URB.TOTL,
SP.POP.TOTL, part.of.urban.center, UC), realpop >= 999999)
G.UC.SUMS$name <- ifelse((G.UC.SUMS$part.of.urban.center==TRUE), G.UC.SUMS$UC, G.UC.SUMS$name)
G.UC.SUMS$pop <-NULL
G.UC.SUMS$row.names <-NULL
G.UC.SUMS<-G.UC.SUMS[!duplicated(G.UC.SUMS$realpop),]
G.UC.SUMS2<-aggregate(G.UC.SUMS$realpop, by=list(country=G.UC.SUMS$country), FUN=sum)
G.UC.SUMS2["SUM.fake.MCTY"] <- G.UC.SUMS2$x
G.UC.SUMS2$x <- NULL
G <- merge(G, G.UC.SUMS2, by=c("country"), all.x=TRUE)
rm(G.UC.SUMS2, G.UC.SUMS)
G.SC.SUMS <- subset(G, select = c(realpop, country, name, pop, Population, EN.URB.LCTY.UR, EN.URB.MCTY, SP.URB.TOTL,
SP.POP.TOTL, part.of.urban.center, UC), realpop <= 999999)
G.SC.SUMS$name <- ifelse((G.SC.SUMS$part.of.urban.center==TRUE), G.SC.SUMS$UC, G.SC.SUMS$name)
G.SC.SUMS$pop <-NULL
G.SC.SUMS$row.names <-NULL
G.SC.SUMS<-G.SC.SUMS[!duplicated(G.SC.SUMS$realpop),]
G.SC.SUMS2<-aggregate(G.SC.SUMS$realpop, by=list(country=G.SC.SUMS$country), FUN=sum)
G.SC.SUMS2["SUM.fake.REST"] <- G.SC.SUMS2$x
G.SC.SUMS2$x <- NULL
G <- merge(G, G.SC.SUMS2, by=c("country"), all.x=TRUE)
G["Restpop.WDI"]<- G$SP.URB.TOTL - G$EN.URB.MCTY
G["MCTYpop.WDI"]<- G$EN.URB.MCTY - G$EN.URB.LCTY.UR
# bring all UC-bound cities back to their original estimate
G$realpop <- ifelse(G$part.of.urban.center==TRUE, G$pop, G$realpop)
G$realpop <- ifelse(G$largestC==1&(!is.na(G$EN.URB.LCTY.UR)),G$EN.URB.LCTY.UR, G$realpop)
# chaning the size of all cities under 1m inhabitants so the county sum fits the WDI
G$realpop <- ifelse((G$realpop!=G$EN.URB.LCTY.UR)& (G$realpop<=999999)&(!is.na(G$EN.URB.LCTY.UR))&(!is.na(G$SUM.fake.REST))&
(!is.na(G$Restpop.WDI))&(G$Restpop.WDI>=999999)&(G$SUM.fake.REST>=999999), (G$realpop*G$Restpop.WDI/G$SUM.fake.REST), G$realpop)
# chaning the size of all cities over 1m inhabitants so the county sum fits the WDI
G$realpop <- ifelse((G$realpop!=G$EN.URB.LCTY.UR)&(G$realpop>=999999)&(!is.na(G$EN.URB.LCTY.UR))&(!is.na(G$SUM.fake.MCTY))&
(!is.na(G$MCTYpop.WDI))&(G$MCTYpop.WDI>=1999999)&(G$SUM.fake.REST>=1999999), (G$realpop*G$MCTYpop.WDI/G$SUM.fake.MCTY), G$realpop)
# bringing it back into the WC.UC.dist
G <-G[order(-G$pop, G$name), ]
WC.UC.dist <-WC.UC.dist[order(-WC.UC.dist$pop, WC.UC.dist$name), ]
WC.UC.dist["old.pop"] <- WC.UC.dist$pop
WC.UC.dist$pop <- G$realpop
WC.UC.dist["old.name"] <- as.character(WC.UC.dist$name)
WC.UC.dist$name <- ifelse((G$part.of.urban.center==TRUE), as.character(G$UC), as.character(WC.UC.dist$old.name))
rm(G.SC.SUMS2, G.SC.SUMS)
rm(G)
#write csv
write.csv(WC.UC.dist, "Cache/WC.UC.dist.csv")
#################### Load some GIS Data into the set ;) ########################
C <- WC.UC.dist
unzip("Downloaded_Data/Downloaded_Raster_Data.zip", exdir="Downloaded_Data")
###
# Distance to coast in km
# http://worldgrids.org/doku.php?id=wiki:layers
RASTERcoastdist <- raster("Downloaded_Data/DICGSH1a.tif")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["coast.dist"] <- raster::extract(RASTERcoastdist, p1)
C["coast.dist"] <- ifelse(p1$coast.dist>=0, 0, round((p1$coast.dist^2)^0.5))
# Plus Countries Minimum
Rank.COASTDIST.MIN<-aggregate(C$coast.dist, by=list(C$country.etc), FUN=min)
colnames(Rank.COASTDIST.MIN)[1] <- "country.etc"
colnames(Rank.COASTDIST.MIN)[2] <- "coast.dist.MIN"
C <- merge(C, Rank.COASTDIST.MIN, by=c("country.etc"), all.x=TRUE)
rm(Rank.COASTDIST.MIN, RASTERcoastdist)
###
# Urban Land Cover in %
# http://worldgrids.org/doku.php?id=wiki:g19esa3
RASTERurban <- raster("Downloaded_Data/G19ESA3a.tif")
RASTERurban <- aggregate(RASTERurban, fact=20, fun=max, na.rm=TRUE)
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["urbn.cover"] <- raster::extract(RASTERurban, p1, method='bilinear')
C["urbn.cover"] <- round(p1$urbn.cover)
rm(RASTERurban)
###
# travel time to major city in minutes (2000)
# http://worldgrids.org/doku.php?id=wiki:layers
RASTERacess <- raster("Downloaded_Data/GACGEM2a.tif")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["access"] <- raster::extract(RASTERacess, p1)
C["access"] <- round(p1$access)
unlink("Downloaded_Data/GACGEM2a.tif")
# Plus Countries Maximum
Rank.ACCESS.MAX<- ifelse(!is.na(C$access), as.numeric(C$access), 0)
Rank.ACCESS.MAX<-aggregate(Rank.ACCESS.MAX, by=list(C$country.etc), FUN=max)
colnames(Rank.ACCESS.MAX)[1] <- "country.etc"
colnames(Rank.ACCESS.MAX)[2] <- "ACCESS.MAX"
C <- merge(C, Rank.ACCESS.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.ACCESS.MAX, RASTERacess)
###
# Stable light shining at night in mean reflection levels 1-63 from 1992 to 2010
# http://worldgrids.org/doku.php?id=wiki:layers
RASTERlight<- raster("Downloaded_Data/LNMDMS2a.tif")
RASTERlight <- aggregate(RASTERlight, fact=2, fun=max, na.rm=TRUE)
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["light"] <- raster::extract(RASTERlight, p1, method='bilinear')
C["light"] <- round(p1$light)
# Plus Countries Maximum
Rank.LIGHT.MAX<- ifelse(!is.na(C$light), as.numeric(C$light), 0)
Rank.LIGHT.MAX<-aggregate(Rank.LIGHT.MAX, by=list(C$country.etc), FUN=max)
colnames(Rank.LIGHT.MAX)[1] <- "country.etc"
colnames(Rank.LIGHT.MAX)[2] <- "light.MAX"
C <- merge(C, Rank.LIGHT.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.LIGHT.MAX, RASTERlight)
###
# Economic activity in millions of dollars per km2 (2006)
# http://ngdc.noaa.gov/eog/dmsp/download_gdp.html
download.file("http://ngdc.noaa.gov/eog/data/GDP/GDP_grid_flt.tif.gz", "Downloaded_Data/GDP_grid_flt.tif.gz")
gunzip("Downloaded_Data/GDP_grid_flt.tif.gz", destname="Downloaded_Data/GDP_grid_flt.tif")
RASTERgdp <- raster("Downloaded_Data/GDP_grid_flt.tif")
RASTERgdp <- aggregate(RASTERgdp, fact=10, fun=max, na.rm=TRUE) # take 10km Radius max
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["gdp"] <- raster::extract(RASTERgdp, p1, method='bilinear')
C["city.gdp"] <- round(p1$gdp)
# Plus Countries Maximum
Rank.GDP.MAX<-aggregate(C$city.gdp, by=list(C$country.etc), FUN=max)
colnames(Rank.GDP.MAX)[1] <- "country.etc"
colnames(Rank.GDP.MAX)[2] <- "gdp.MAX"
C <- merge(C, Rank.GDP.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.GDP.MAX, RASTERgdp)
###
# The Night Light Development Index for 2006, exquality in distribution of light (0-1 Lorenz Curve)
# ngdc.noaa.gov
RASTERnldi <- raster("Downloaded_Data/NLDI_2006_0p25_rev20111230.tif")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["nldi"] <- raster::extract(RASTERnldi, p1, method='bilinear')
C["nldi"] <- ifelse(p1$nldi<=0 | p1$nldi>=1, NA, as.numeric(p1$nldi))
# Plus Countries Maximum
Rank.NLDI.MAX<- ifelse(!is.na(C$nldi), as.numeric(C$nldi), 0)
Rank.NLDI.MAX<-aggregate(Rank.NLDI.MAX, by=list(C$country.etc), FUN=max)
colnames(Rank.NLDI.MAX)[1] <- "country.etc"
colnames(Rank.NLDI.MAX)[2] <- "nldi.MAX"
C <- merge(C, Rank.NLDI.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.NLDI.MAX, RASTERnldi)
###
# Population Density with 50km resolution (1990)
# NASA's Earth Observing System Data and Information System
RASTER90pop <- raster("Downloaded_Data/glds90ag30.asc")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["dens.90"] <- raster::extract(RASTER90pop, p1, method='bilinear')
C["dens.90"] <- round(p1$dens.90)
# Plus Countries Maximum
Rank.POP90.MAX<-aggregate(C$dens.90, by=list(C$country.etc), FUN=max)
colnames(Rank.POP90.MAX)[1] <- "country.etc"
colnames(Rank.POP90.MAX)[2] <- "dens.90.MAX"
C <- merge(C, Rank.POP90.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.POP90.MAX, RASTER90pop)
###
# Population Density with 50km resolution (1995)
# NASA's Earth Observing System Data and Information System
RASTER95pop <- raster("Downloaded_Data/glds95ag30.asc")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["dens.95"] <- raster::extract(RASTER95pop, p1, method='bilinear')
C["dens.95"] <- round(p1$dens.95)
# Plus Countries Maximum
Rank.POP95.MAX<-aggregate(C$dens.95, by=list(C$country.etc), FUN=max)
colnames(Rank.POP95.MAX)[1] <- "country.etc"
colnames(Rank.POP95.MAX)[2] <- "dens.95.MAX"
C <- merge(C, Rank.POP95.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.POP95.MAX, RASTER95pop)
###
# Population Density with 50km resolution (2000)
# NASA's Earth Observing System Data and Information System
RASTER00pop <- raster("Downloaded_Data/glds00ag30.asc")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["dens.00"] <- raster::extract(RASTER00pop, p1, method='bilinear')
C["dens.00"] <- round(p1$dens.00)
# Plus Countries Maximum
Rank.POP00.MAX<-aggregate(C$dens.00, by=list(C$country.etc), FUN=max)
colnames(Rank.POP00.MAX)[1] <- "country.etc"
colnames(Rank.POP00.MAX)[2] <- "dens.00.MAX"
C <- merge(C, Rank.POP00.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.POP00.MAX, RASTER00pop)
###
# Population Density Estimate with 50km resolution (2005)
# NASA's Earth Observing System Data and Information System
RASTER05pop <- raster("Downloaded_Data/glds05ag30.asc")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["dens.05"] <- raster::extract(RASTER05pop, p1, method='bilinear')
C["dens.05"] <- round(p1$dens.05)
# Plus Countries Maximum
Rank.POP05.MAX<-aggregate(C$dens.05, by=list(C$country.etc), FUN=max)
colnames(Rank.POP05.MAX)[1] <- "country.etc"
colnames(Rank.POP05.MAX)[2] <- "dens.05.MAX"
C <- merge(C, Rank.POP05.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.POP05.MAX, RASTER05pop)
###
# Population Density Estimate with 50km resolution (2010)
# NASA's Earth Observing System Data and Information System
RASTER10pop <- raster("Downloaded_Data/glds10ag30.asc")
p1 <- data.frame(lon=C$lon, lat=C$lat)
p1["dens.10"] <- raster::extract(RASTER10pop, p1, method='bilinear')
C["dens.10"] <- round(p1$dens.10)
# Plus Countries Maximum
Rank.POP10.MAX<-aggregate(C$dens.10, by=list(C$country.etc), FUN=max)
colnames(Rank.POP10.MAX)[1] <- "country.etc"
colnames(Rank.POP10.MAX)[2] <- "dens.10.MAX"
C <- merge(C, Rank.POP10.MAX, by=c("country.etc"), all.x=TRUE)
rm(Rank.POP10.MAX, RASTER10pop)
WC.UC.dist.gis <- C
rm(C, p1)
write.csv(WC.UC.dist.gis, "Cache/WC.UC.dist.gis.csv")
unlink("Downloaded_Data/NLDI_2006_0p25_rev20111230.tif")
unlink("Downloaded_Data/GDP_grid_flt.tif")
unlink("Downloaded_Data/LNMDMS2a.tif")
unlink("Downloaded_Data/DICGSH1a.tif")
unlink("Downloaded_Data/G19ESA3a.tif")
# Load Packages if necessary
source("0 - Loading Packages.R")
#############################################################################################################
################### Loading Datasets previously gathered, cleaned and partially merged ######################
#############################################################################################################
# Global Terrorism Database (GTD) with some new scales and categories we introduced to the GTD for our purposes
if(file.exists("Cache/GTD.csv")) {GTD <- read.csv("Cache/GTD.csv")} else{source("1.a - Global Terrorism Database.R")}
# Country level data from the World Bank Development Indicators (WDI) and the The Correlates of War (COW) project data on wars.
if(file.exists("Cache/CountryData.csv")){CountryData <- read.csv("Cache/CountryData.csv")} else{source("1.b - Country Data.R")}
# City level data from a number of sources, including web scraping and GIS analysis
if(file.exists("Cache/WC.UC.dist.csv")) {WC.UC.dist <- read.csv("Cache/WC.UC.dist.gis.csv")} else{source("1.c - City Data.R")}
#############################################################################################################
############################# Merge the Data Sets into a "PreGTD"###########################################
#############################################################################################################
###### Merge City and Country Data ######
# create merge variable
WC.UC.dist["merge"] <- paste(WC.UC.dist$country.etc, WC.UC.dist$old.name, sep="")
WC.UC.dist <- WC.UC.dist[order(WC.UC.dist$merge, WC.UC.dist$capital, -WC.UC.dist$pop),]
WC.UC.dist <- WC.UC.dist[!duplicated(WC.UC.dist$merge), ]
X <- WC.UC.dist
# create all missing years in the city data artificially
X["start"] <- 1970
X["end"] <- 2013
X <- TimeFill(X, GroupVar = 'merge', StartVar = 'start', EndVar = 'end')
X$TimeFilled <- NULL
# merge city and country data
WC.UC.full<- merge(X, WC.UC.dist, by=c("merge"), all.x=TRUE)
WC.UC.full <- merge(WC.UC.full, CountryData, by.x=c("country.etc", "Time"), by.y=c("country", "year"), all.x=TRUE, sort=TRUE)
rm(X)
# minor cleanups
WC.UC.full$part.of.urban.center[is.na(WC.UC.full$part.of.urban.center)] <- FALSE
WC.UC.full$in.urban.centers.environment[is.na(WC.UC.full$in.urban.centers.environment)] <- FALSE
WC.UC.full$in.urban.centers.environment <- recode(WC.UC.full$in.urban.centers.environment, "TRUE=1")
WC.UC.full$part.of.urban.center <- recode(WC.UC.full$part.of.urban.center, "TRUE=1")
WC.UC.full$largestC[is.na(WC.UC.full$largestC)] <- 0
WC.UC.full$largest.UC[is.na(WC.UC.full$largest.UC)] <- 0
###### Change City Size on yearly basis with WDi data and introduce relative city size (Rel.CS) ######
# prepare
G2<-WC.UC.full
G2$SP.URB.TOTL <- as.numeric(G2$SP.URB.TOTL )
G2$MAX.URB.TOTL <- as.numeric(G2$MAX.URB.TOTL)
G2$EN.URB.MCTY <- as.numeric(G2$EN.URB.MCTY)
G2$MAX.URB.MCTY <- as.numeric(G2$MAX.URB.MCTY)
G2$EN.URB.LCTY.UR <- as.numeric(G2$EN.URB.LCTY.UR)
G2$MAX.URB.LCTY.UR <- as.numeric(G2$MAX.URB.LCTY.UR)
G2$WC.UC.dist.km <- as.numeric(G2$WC.UC.dist.km)
G2$Area <- as.numeric(G2$Area)
G2["year"] <- as.numeric(G2$Time)
G2["pop.2013"] <- as.numeric(G2$pop)
G2$old.pop <- G2$pop
G2$pop <- NULL
# Area Manipulation for UC's, in order to account for growing urban centers incorporating less in the past
G2$Area <-ifelse(G2$largest.UC==1 & !is.na(G2$EN.URB.LCTY.UR) & !is.na(G2$MAX.URB.LCTY.UR)  & (G2$EN.URB.LCTY.UR/G2$MAX.URB.LCTY.UR)<=1 &
(G2$EN.URB.LCTY.UR/G2$MAX.URB.LCTY.UR)>=0.05, (G2$EN.URB.LCTY.UR/G2$MAX.URB.LCTY.UR*G2$Area), G2$Area)
G2$Area <-ifelse(G2$largest.UC==0 & (((G2$EN.URB.MCTY - G2$EN.URB.LCTY.UR)/(G2$MAX.URB.MCTY - G2$MAX.URB.LCTY.UR))<=1)&
(((G2$EN.URB.MCTY - G2$EN.URB.LCTY.UR)/(G2$MAX.URB.MCTY - G2$MAX.URB.LCTY.UR))>=0.05) &
!is.na((G2$EN.URB.MCTY - G2$EN.URB.LCTY.UR)/(G2$MAX.URB.MCTY - G2$MAX.URB.LCTY.UR)),
((G2$EN.URB.MCTY - G2$EN.URB.LCTY.UR)/(G2$MAX.URB.MCTY - G2$MAX.URB.LCTY.UR)*G2$Area), G2$Area)
# re-answering the question again, if a city is part of an UC, now with new Area estimates of all UCs
G2["inUC"] <- ifelse((G2$WC.UC.dist.km <= (15+(((G2$Area)/pi)**0.5))), 1, 0) # 20km + radius of UC as circle
G2["aroundUC"] <- ifelse((G2$WC.UC.dist.km <= (30+(((G2$Area)/pi)**0.5))), 1, 0) # 40km + radius of UC as circle
G2$inUC[is.na(G2$inUC)]<- 0
G2$name <- ifelse((G2$inUC==1), as.character(G2$name), as.character(G2$old.name))
#in case we only have very limited numers on the country population, we put in some first assumptions based on total population
# and UC population
G2["city.population_with_time"] <- ifelse(G2$inUC==1, G2$Population, G2$pop.2013)
G2$city.population_with_time <- ifelse(!is.na(G2$SP.POP.TOTL), G2$pop.2013*G2$SP.POP.TOTL/G2$MAX.POP.TOTL, G2$city.population_with_time)
#in case we only have URB.POP numers, we assume that all cities grew with those numbers each year
G2$city.population_with_time <- ifelse(!is.na(G2$SP.URB.TOTL), G2$pop.2013*G2$SP.URB.TOTL/G2$MAX.URB.TOTL, G2$city.population_with_time)
# if it is the largest city, EN.URB.LCTY.UR is the size estimator for each year
G2$city.population_with_time <-ifelse((G2$inUC==0 & G2$largestC==1 & !is.na(G2$EN.URB.LCTY.UR))|
(G2$inUC==1 & G2$largest.UC==1 & !is.na(G2$EN.URB.LCTY.UR)),
G2$EN.URB.LCTY.UR, G2$city.population_with_time)
# if it is a city with less than 1mil, SP.URB.TOTL minus EN.URB.MCTY is the size estimator for each year
G2$city.population_with_time <- ifelse(G2$city.population_with_time!=G2$EN.URB.LCTY.UR
& G2$pop.2013<=999999
& G2$EN.URB.MCTY <= G2$SP.URB.TOTL & G2$MAX.URB.MCTY <= G2$MAX.URB.TOTL
& !(((G2$SP.URB.TOTL-G2$EN.URB.MCTY)/(G2$MAX.URB.TOTL-G2$MAX.URB.MCTY)
*G2$city.population_with_time)>=G2$EN.URB.LCTY.UR)
& !(((G2$SP.URB.TOTL-G2$EN.URB.MCTY)/(G2$MAX.URB.TOTL-G2$MAX.URB.MCTY))<=0)
& !is.na(G2$EN.URB.MCTY) & G2$MAX.URB.TOTL!=0 & G2$MAX.URB.MCTY!=0
& !is.na(G2$EN.URB.LCTY.UR) & !is.na(G2$SP.URB.TOTL),
((G2$SP.URB.TOTL-G2$EN.URB.MCTY)/(G2$MAX.URB.TOTL-G2$MAX.URB.MCTY)
*G2$city.population_with_time), (G2$city.population_with_time))
# if it is a city with more than 1mil, EN.URB.MCTY minus EN.URB.LCTY.UR is the size estimator for each year
G2$city.population_with_time <- ifelse(G2$city.population_with_time!=G2$EN.URB.LCTY.UR & G2$pop.2013>=999999
& !(((G2$EN.URB.MCTY-G2$EN.URB.LCTY.UR)/
(G2$MAX.URB.MCTY-G2$MAX.URB.LCTY.UR))<=0)
& !(((G2$EN.URB.MCTY-G2$EN.URB.LCTY.UR)/
(G2$MAX.URB.MCTY-G2$MAX.URB.LCTY.UR)
*G2$city.population_with_time)>=G2$EN.URB.LCTY.UR)
& !is.na(G2$EN.URB.MCTY) & !is.na(G2$EN.URB.LCTY.UR) & G2$MAX.URB.MCTY!=0,
((G2$EN.URB.MCTY-G2$EN.URB.LCTY.UR)/(G2$MAX.URB.MCTY-G2$MAX.URB.LCTY.UR)
*G2$city.population_with_time), G2$city.population_with_time)
# some final cleaning of minor leftovers
G2$city.population_with_time <- ifelse(!G2$city.population_with_time<=G2$EN.URB.LCTY.UR & G2$largestC==1,
G2$EN.URB.LCTY.UR, G2$city.population_with_time)
G2$city.population_with_time <- ifelse(!G2$city.population_with_time<=G2$EN.URB.LCTY.UR & G2$largestC==0,
runif(1, (G2$EN.URB.LCTY.UR/10), G2$EN.URB.LCTY.UR), G2$city.population_with_time)
###### introduce some new variable, because finally we can ######
# introducing relative city size to countries largest city
G2["Rel.CS"] <- G2$city.population_with_time/G2$EN.URB.LCTY.UR
# rename the new population estimate
G2["pop.that.year"] <-  round(G2$city.population_with_time)
# introducing yearly population size rank of each city within its country into the city data
G2["mergerr"] <-data.frame(paste(G2$country.etc, G2$name, G2$year, sep=""))
GX <- G2
GX <- GX[order(GX$mergerr, GX$capital, -GX$pop.that.year),]
GX <- GX[!duplicated(GX$mergerr), ]
GXX <- GX[order(GX$country.etc, GX$year, -GX$pop.that.year, -GX$long),]
GXX["RANK.Country"] <- unlist(with(GXX, tapply(-pop.that.year, list(Time, country.etc), function(x) rank(x, ties.method= "min"))))
GXX <- subset(GXX, select=c(mergerr, RANK.Country), row.names=NULL)
G2 <- merge(G2, GXX, by=c("mergerr"), all.x=TRUE)
rm(GXX)
# put the maxium rank per year and country in the GTD
Rank.Country.MAX<-aggregate(G2$RANK.Country, by=list(G2$year, G2$country.etc), FUN=max)
colnames(Rank.Country.MAX)[1] <- "iyear"
colnames(Rank.Country.MAX)[2] <- "country_txt"
colnames(Rank.Country.MAX)[3] <- "Rank.C.MAX"
GTDr <- merge(GTD, Rank.Country.MAX, by=c("iyear", "country_txt"), all.x=TRUE)
rm(Rank.Country.MAX)
# introducing yearly population size rank of each city in the world comparasion
GXX<- GX[order(GX$year, -GX$pop.that.year),]
GXX["RANK.World"] <-unlist(with(GXX, tapply(-pop.that.year, year, function(x) rank(x, ties.method= "min"))))
GXX <- subset(GXX, select=c(mergerr, RANK.World), row.names=NULL)
G2 <- merge(G2, GXX, by=c("mergerr"), all.x=TRUE)
G2$mergerr <- NULL
rm(GXX,GX)
# put the maxium rank per year in the GTD
Rank.World.MAX<-aggregate(G2$RANK.World, by=list(G2$year), FUN=max)
setwd("C:/Users/Lokus/Dropbox/UrbanTerror")
et_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain", "watercolor", "toner"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain", "watercolor", "toner"))
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
packages <- c("foreign", "car", "RCurl", "ggplot2", "WDI", "rtiff", "httr", "iterators", "dplyr", "plyr", "mapproj",
"stargazer", "rgdal", "sp", "dismo","XML", "maps", "ggmap", "Imap", "geonames", "GSIF", "tiff",
"raster", "gdalUtils","geosphere", "maptools", "rgeos", "foreach", "DataCombine", "R.utils")
ipak(packages)
rm(packages, ipak)
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain", "watercolor", "toner"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 10, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 2, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 22, maptype = c("terrain"))
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 2, maptype = "terrain")
get_stamenmap(bbox = c(left = -95.80204, bottom = 29.38048, right = -94.92313, top = 30.14344),
zoom = 2, maptype = terrain)
